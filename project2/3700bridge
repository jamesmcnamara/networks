#!/usr/bin/python -u
# The -u makes output unbuffered, so it will show up immediately
from __future__ import print_function

import json
import sys
from collections import defaultdict
from socket import socket, AF_UNIX, SOCK_SEQPACKET
from select import select
from threading import Thread, Lock, Event


class Timeout(Thread):
    def __init__(self, target, timer):
        Thread.__init__(self)
        self.target = target
        self.timer = timer
        self.event = Event()
        self.start()

    def restart(self):
        self.event.set()

    def run(self):
        while True:
            self.event.wait(self.timer) 
            if self.event.is_set():
                self.event.clear()
            else:
                if self.target():
                    print_debug("returning", "cyan")
                    break 


def print_debug(msg, color="red"):
    color_codes = {"red": 31, 
                   "green": 32, 
                   "yellow": 33, 
                   "blue": 34, 
                   "magenta": 35, 
                   "cyan": 36}
    COLOR = "\\\e[1;{}m"
    CLEAR = "\\\e[0m"
    print(COLOR.format(color_codes[color]) + '[DEBUG] ' + msg + CLEAR)


class Blacklist(object):
    def __init__(self):
        self.ports = set()
        self.lock = Lock()

    def __contains__(self, port):
        with self.lock:
            return port in self.ports
    
    def add(self, port):
        with self.lock:
            self.ports.add(port)

    def reset(self):
        with self.lock:
            self.ports = set()

    def remove(self, port):
        with self.lock:
            if port in self.ports:
                self.ports.remove(port)

class Bridge(object):
    def __init__(self, id, lans):
        self.id = id
        self.lans = {port: lan for port, lan in map(self.create_socket, lans)}
        self.bridge_timers = {}
        self.bridge_timers_lock = Lock()
        self.root = self.id
        self.cost = 0
        self.root_port = 0
        self.router = {}
        self.ids = set()
        self.blacklist = Blacklist()
        self.router_lock = Lock()
        self.root_timeout = None
        self.bpdu_updater =  Timeout(self.broadcast_bpdu, 0.5)

    def expire_port(self, port):
        def port_expire():
            with self.bridge_timers_lock:
                self.blacklist.remove(port)
                if port == self.root_port:
                    self.reset_root()
                else:
                    if port in self.bridge_timers:
                        self.bridge_timers.pop(port)
            return True
        return port_expire

    @staticmethod
    def create_socket(lan):
        """ creates sockets and connects to them """
        def pad(name):
            """ pads the name with null bytes at the end """
            return '\0' + name + '\0' * (107 - len(name))
        s = socket(AF_UNIX, SOCK_SEQPACKET)
        s.connect(pad(lan))
        return s.fileno(), s

    def check_network(self):
        ready = select(self.lans.values(), [], [], 0)[0]
        for lan in ready:
            msg = json.loads(lan.recv(1500))
            port = lan.fileno()
            if msg['type'] == 'bpdu':
                self.update_or_add_bridge(port)
                self.process_bpdu(msg, port)
            else:
                id = msg['message']['id']
                if id in self.ids or port in self.blacklist:
                    print("Not forwarding message {} from {} to {}"
                        .format(id, port, msg['dest']))
                    continue
                self.ids.add(id)
                self.forward_message(msg, port)

    def process_bpdu(self, bpdu, port):
        bpdu_root = int(bpdu['message']['root'], 16)
        bpdu_cost = bpdu['message']['cost']
        if (bpdu_root < int(self.root, 16) or 
                bpdu_root == self.root and 
                bpdu_cost + 1 < self.cost):
            self.root = bpdu['message']['root']
            self.cost = int(bpdu['message']['cost']) + 1
            self.root_port = port
            print_debug("New root: {}/{}".format(self.id, self.root), color='green')
            print_debug("Root port: {}/{}".format(self.id, self.root_port))
            self.broadcast_bpdu()
            self.bpdu_updater.restart()
            self.blacklist.reset() 
        elif (bpdu_root == self.root
                and bpdu_cost == self.cost
                and int(bpdu['message']['id'], 16) < int(self.id, 16)):
            self.blacklist.add(port)

    def forward_message(self, msg, port):
        id, port, src, dst = msg['message']['id'], port, msg['source'], msg['dest']
        print("Received message {} on port {} from {} to {}".format(id, port, src, dst))
        if self.lookup_host(src) != port:
            print("Designated port: {}/{}".format(src, port))
            self.set_host(src, port)
        if self.lookup_host(dst):
            dst_port = self.lans[self.lookup_host(dst)].fileno()
            if dst_port == port:
                print("Not forwarding redundant packet {} on {}".format(id, port))
                return
            print("Forwarding message {} to port {}".format(id, dst_port))
            self.send(dst_port, msg)
        else:
            print("Broadcasting message {} on all ports".format(id))
            self.broadcast(msg, exclude=[port])

    def update_or_add_bridge(self, port):
        with self.bridge_timers_lock:
            if port in self.bridge_timers:
                self.bridge_timers[port].restart()
            else:
                self.bridge_timers[port] = Timeout(self.expire_port(port), 0.75)

    def broadcast_bpdu(self):
        self.broadcast(self.build_bpdu())
        return False

    def reset_root(self):
        self.root = self.id
        self.cost = self.root_port = 0
        self.bridge_timers = {}
        with self.router_lock:
            self.router = {}

    def lookup_host(self, host):
        with self.router_lock:
            return self.router.get(host)

    def set_host(self, host, port):
        with self.router_lock:
            self.router[host] = port


    def build_bpdu(self):
        return {
            'type': 'bpdu',
            'source': self.id,
            'dest': 'ffff',
            'message': {
                'id': self.id,
                'root': self.root,
                'cost': self.cost
            }
        }

    def send(self, port, msg):
        self.lans[port].sendall(json.dumps(msg))

    def broadcast(self, msg, exclude=None):
        if exclude is None:
            exclude = []
        for port in self.lans:
            if port not in exclude:
                self.send(port, msg)


def main():
    id, lans = sys.argv[1], sys.argv[2:]
    bridge = Bridge(id, lans)
    while True:
        bridge.check_network()

if __name__ == "__main__":
    main()
